#include <iostream>

using namespace std;

// 과제
// 1. 오늘 배운 자료형들
// sizeof(자료형), 값 출력

// 2. 메모리 4영역 조사

// 3. 연산자에 대해 공부(extra)

#pragma region 컴파일 4단계
// 전처리기
// - # 붙은 얘들을 정리해준다.
// - 주석 처리
// 
// 컴파일러
// - 문법
// - 고수준언어를 저수준의 언어(어셈블리어)로 바꾼다.
// 
// 어셈블러
// - 어셈블리어를 기계어로 바꾼다.
// 
// 링커
// - 라이브러리를 결합
// - .h , .cpp를 결합
#pragma endregion

// 64비트 환경
// - 처리하는 단위가 64비트 단위로 처리
// 32비트 환경
// - 32비트 단위로 처리

// bit
// 0,1 로 표시되는 가장 작은 단위
// byte : 8bit

// 변수
// 변수 선언 방법
// (자료형) (변수이름) = (초기화);

// 자료형
// DataType
// 내가 만약에 정수를 컴퓨터한테 알려주고 싶다.

// 정수형 자료형
// - int
// 크기 : 4바이트 - 32비트
// 나타낼 수 있는 수: +21억 ~ -21억 (2^31 -1 ~ -2^31) -> 2^32
int aInt = 1;

// - short
// 크기 : 2바이트 - 16비트
// 나타낼 수 있는 수: 32767 ~ -32768 (2^15 -1 ~ - 2^15) -> 2^16
short aShort = 5;

// - __int64, long long
// 크기 : 8바이트 : 64비트
// 나타낼 수 있는 수: (2^63 - 1 ~ -2^63) -> 2^64

// 음의 수 처리 방법
// - 맨 앞비트를 부호로 처리하자
// => 2 보수법
// 1. 모든 비트를 반대로 바꿔준다.
// 2. + 1을 한다

// 부호가 없는 정수형(자연수)
unsigned short aUshort = 15;
unsigned int aUint = 11;
unsigned __int64 aUint64 = 150;

// 정수형 오버플로우
// 정수형 언더플로우

// 실수형(소수가 포함된)
// float : 4바이트 -> 32비트
// (1) : 부호, (8) : 지수, (23): 유효숫자
// double : 8바이트
float aFloat = 2.125f;
double aDouble = 2.125;

// 부동소수점 (떠다니는 소수점)
// 100.1 -> +1.001 x 10 ^2
// 2.125
// 0b 10.001
// -> 0b 1.0001 x 2^1
// 부호(0) 지수(1 + 127) 유효숫자(0001)
// 0 1000 0000 000100000000000

// 논리형
// 크기 : 1바이트
bool aBool = true; // 0 아니면 true, 0일 때만 false

// 문자형 (정수형)
// char
// 크기 : 1바이트
char aChar = 'a'; // 97 아스키 코드
// 유니코드(wchar)
// - UTF-8 : 알파벳, 숫자(1바이트) / 한글, 중국어(3바이트)
// - UTF-16 :  알파벳, 숫자, 한글, 중국어(2바이트)/ 고대문자(4바이트)

// Escape Sequence
// \n : 줄바꿈 ... endl;
// \t : Tab
// \' : '표시
// \" : "표시
// \0 : NULL표시

// 사용자 정의 자료형
struct Vector2
{
    float _x;
    float _y;
};

int main()
{
    Vector2 pos;
    pos._x = 0.0f;
    pos._y = 0.0f;

    cout << "Vector2 자료형의 크기 : " << sizeof(Vector2) << "입니다." << endl;
    cout << "pos의 x 값 : " << pos._x << "\t pos의 y 값 : " << pos._y << endl;

    // 
}
